# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/117Em059MbiSkRh6QS8ZmjzVIUjqxsywC
"""

!pip install openslide-bin
!pip install openslide-python openslide-bin

import openslide

# √énlocuie»ôte cu calea fi»ôierului tƒÉu WSI
wsi_path = "/content/wsi_input/11CO054-f6a7f764-2495-4a1d-89a2-e12f51.svs"

try:
    slide = openslide.OpenSlide(wsi_path)
    print("‚úÖ Fi»ôierul este compatibil cu OpenSlide.")

    # Informa»õii generale
    print(f"- Dimensiuni nivel 0: {slide.dimensions}")
    print(f"- NumƒÉr niveluri: {slide.level_count}")
    print(f"- Dimensiuni pe niveluri: {slide.level_dimensions}")

    # Rezolu»õia √Æn microni per pixel
    mpp_x = slide.properties.get("openslide.mpp-x")
    mpp_y = slide.properties.get("openslide.mpp-y")
    print(f"- Rezolu»õie: {mpp_x} x {mpp_y} microni/pixel")

    # Vendor info
    vendor = slide.properties.get("openslide.vendor")
    print(f"- Vendor: {vendor}")

    # Po»õi salva un thumbnail (ex: 512x512)
    thumb = slide.get_thumbnail((512, 512))
    thumb.save("/content/thumbnail.png")
    print("üñºÔ∏è Thumbnail salvat: /content/thumbnail.png")

    slide.close()

except openslide.OpenSlideUnsupportedFormatError:
    print("‚ùå Fi»ôierul NU este compatibil cu OpenSlide.")
except Exception as e:
    print(f"‚ùå Eroare: {e}")

import openslide
import os
import numpy as np
from PIL import Image
import cv2
from sklearn.cluster import KMeans
from tqdm import tqdm

# SetƒÉri
wsi_path = "/content/wsi_input/11CO054-f6a7f764-2495-4a1d-89a2-e12f51.svs"
patch_size = 224
output_dir = "/content/wsi_output"
os.makedirs(output_dir, exist_ok=True)

# Deschidere WSI »ôi generare thumbnail
slide = openslide.OpenSlide(wsi_path)
thumb = slide.get_thumbnail((1024, 1024))
thumb_np = np.array(thumb)

# KMeans pe thumbnail pentru segmentarea »õesutului (background = cel mai luminos cluster)
h, w, _ = thumb_np.shape
flat = thumb_np.reshape(-1, 3).astype(np.float32) / 255.0
feats = np.c_[flat.mean(1), flat.std(1)]
km = KMeans(n_clusters=2, random_state=0, n_init="auto").fit(feats)
labels = km.labels_.reshape(h, w)
bg_cluster = np.argmax([feats[km.labels_ == i, 0].mean() for i in range(2)])
mask = (labels != bg_cluster).astype(np.uint8) * 255

# Morfologie (curƒÉ»õare mascƒÉ)
kernel = np.ones((5, 5), np.uint8)
mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

# Mapare mascƒÉ la dimensiunile nivelului 0
w0, h0 = slide.dimensions
mask_resized = cv2.resize(mask, (w0, h0), interpolation=cv2.INTER_NEAREST)

# Extragem patchuri doar din zonele cu »õesut
count = 0
for y in tqdm(range(0, h0 - patch_size, patch_size)):
    for x in range(0, w0 - patch_size, patch_size):
        region_mask = mask_resized[y:y+patch_size, x:x+patch_size]
        if np.count_nonzero(region_mask) == 0:
            continue  # doar fundal

        patch = slide.read_region((x, y), 0, (patch_size, patch_size)).convert("RGB")
        patch.save(os.path.join(output_dir, f"patch_{count:05d}.png"))
        count += 1

print(f"‚úÖ Total patchuri extrase: {count}")
slide.close()

import os
import shutil
from tqdm import tqdm

src_dir = "/content/wsi_output"
dst_dir = "/content/patches_for_ssl"
os.makedirs(dst_dir, exist_ok=True)

# Copiere patchuri (dureazƒÉ c√¢teva minute pentru 50k imagini)
patches = sorted(os.listdir(src_dir))
for fname in tqdm(patches, desc="Copiere patchuri"):
    shutil.copy(os.path.join(src_dir, fname), os.path.join(dst_dir, fname))

print(f"‚úÖ {len(patches)} imagini copiate √Æn {dst_dir}")

# CURƒÇ»öARE RAM »ôi GPU
import gc
import torch
gc.collect()
if torch.cuda.is_available():
    torch.cuda.empty_cache()

# 1. Folder nou cu doar 5.000 imagini
import os, random, shutil
from tqdm import tqdm

src = "/content/patches_for_ssl"
dst = "/content/ssl_subset_5k"
os.makedirs(dst, exist_ok=True)

sampled = random.sample(os.listdir(src), 5000)
for f in tqdm(sampled, desc="Copiere subset 5k"):
    shutil.copy(os.path.join(src, f), os.path.join(dst, f))

# 2. Dataset »ôi loader (cu batch 16)
from torchvision import transforms
from PIL import Image
from torch.utils.data import Dataset, DataLoader

transform = transforms.Compose([
    transforms.RandomResizedCrop(224, scale=(0.5, 1.0)),
    transforms.RandomHorizontalFlip(),
    transforms.ColorJitter(0.4, 0.4, 0.4, 0.1),
    transforms.RandomGrayscale(p=0.2),
    transforms.ToTensor(),
    transforms.Normalize([0.5]*3, [0.5]*3)
])

class SimCLRDataset(Dataset):
    def __init__(self, folder, transform):
        self.paths = [os.path.join(folder, f) for f in os.listdir(folder) if f.endswith('.png')]
        self.transform = transform
    def __len__(self): return len(self.paths)
    def __getitem__(self, i):
        img = Image.open(self.paths[i]).convert("RGB")
        return self.transform(img), self.transform(img)

dataset = SimCLRDataset("/content/ssl_subset_5k", transform)
loader = DataLoader(dataset, batch_size=16, shuffle=True, drop_last=True, num_workers=0)

# 3. Model SimCLR cu ResNet50 + antrenare light
import torch
from torch import nn
from torchvision import models
from lightly.models import SimCLR
from lightly.loss import NTXentLoss
from tqdm import tqdm

resnet = models.resnet50(weights=None)
backbone = nn.Sequential(*list(resnet.children())[:-1])
model = SimCLR(backbone, num_ftrs=2048)

device = "cuda" if torch.cuda.is_available() else "cpu"
model = model.to(device)

optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
criterion = NTXentLoss()

print("üöÄ AntrenƒÉm cu batch 16 pe subset 5k")
for epoch in range(3):
    model.train()
    total_loss = 0
    for x0, x1 in tqdm(loader, desc=f"Epoca {epoch+1}/3"):
        x0, x1 = x0.to(device), x1.to(device)
        z0, z1 = model(x0, x1)
        loss = criterion(z0, z1)
        loss.backward()
        optimizer.step()
        optimizer.zero_grad()
        total_loss += loss.item()
    print(f"‚úÖ Epoca {epoch+1}: loss mediu {total_loss / len(loader):.4f}")

# 4. Salvare encoder
torch.save(model.backbone.state_dict(), "/content/simclr_backbone_resnet50_light.pth")
print("‚úÖ Encoder salvat: /content/simclr_backbone_resnet50_light.pth")